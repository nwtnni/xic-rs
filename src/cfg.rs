mod clean;
mod construct;
mod destruct;
mod dot;
mod split;

pub use clean::clean_cfg;
pub use construct::construct_cfg;
pub use destruct::destruct_cfg;
pub(crate) use dot::Dot;
pub use split::split_cfg;

use std::fmt;
use std::fmt::Write as _;
use std::mem;
use std::ops;

use petgraph::algo;
use petgraph::graphmap::DiGraphMap;
use petgraph::graphmap::NeighborsDirected;
use petgraph::visit;

use crate::data::asm;
use crate::data::ir;
use crate::data::lir;
use crate::data::operand::Label;
use crate::data::operand::Temporary;
use crate::data::symbol::Symbol;
use crate::Map;

#[derive(Clone)]
pub struct Cfg<T: Function> {
    name: Symbol,
    metadata: T::Metadata,
    enter: Label,
    exit: Label,

    // Note: we have to expose these for optimizations that modify
    // the control flow graph at the same time as block statements.
    // Otherwise using methods tie together the lifetime of these two
    // fields, and the compiler can't tell the uses are disjoint.
    pub(crate) graph: DiGraphMap<Label, Edge>,
    pub(crate) blocks: Map<Label, Vec<T::Statement>>,
}

impl<T: Function> Cfg<T> {
    pub fn name(&self) -> &Symbol {
        &self.name
    }

    pub fn enter(&self) -> &Label {
        &self.enter
    }

    pub fn exit(&self) -> &Label {
        &self.exit
    }

    pub(crate) fn metadata(&self) -> &T::Metadata {
        &self.metadata
    }

    /// Computes the strongly connected components (SCCs) of this (`reverse`d) control flow graph.
    ///
    /// The list of SCCs is in reverse topological order. Moreover, the list of labels in each
    /// SCC is in postorder, with the component root last.
    pub fn strongly_connected_components(&self, reverse: bool) -> Vec<Vec<Label>> {
        // Wikipedia says:
        //
        // > ... there is nothing special about the order of the nodes within
        // > each strongly connected component...
        //
        // and the `petgraph::algo::tarjan_scc` documentation says:
        //
        // > The order of node ids within each scc is arbitrary...
        //
        // But as far as I can tell from reading the algorithm and source code,
        // the SCCs are generated by postorder traversal?
        if reverse {
            algo::tarjan_scc(visit::Reversed(&self.graph))
        } else {
            algo::tarjan_scc(&self.graph)
        }
    }

    pub fn blocks(&self) -> impl Iterator<Item = (&Label, &[T::Statement])> {
        self.blocks
            .iter()
            .map(|(label, statement)| (label, statement.as_slice()))
    }

    pub fn blocks_mut(&mut self) -> impl Iterator<Item = (&Label, &mut Vec<T::Statement>)> {
        self.blocks.iter_mut()
    }

    pub fn edges(&self) -> impl Iterator<Item = (Label, Label, &Edge)> {
        self.graph.all_edges()
    }

    pub fn incoming(&self, label: &Label) -> NeighborsDirected<Label, petgraph::Directed> {
        self.graph
            .neighbors_directed(*label, petgraph::Direction::Incoming)
    }

    pub fn outgoing(&self, label: &Label) -> NeighborsDirected<Label, petgraph::Directed> {
        self.graph
            .neighbors_directed(*label, petgraph::Direction::Outgoing)
    }

    pub fn neighbors(
        &self,
        direction: petgraph::Direction,
        label: &Label,
    ) -> NeighborsDirected<Label, petgraph::Directed> {
        self.graph.neighbors_directed(*label, direction)
    }

    pub fn edges_directed(
        &self,
        direction: petgraph::Direction,
        label: &Label,
    ) -> impl Iterator<Item = (Label, &'_ Edge)> + '_ {
        self.graph
            .edges_directed(*label, direction)
            .map(move |(predecessor, successor, edge)| match direction {
                petgraph::Direction::Outgoing => (successor, edge),
                petgraph::Direction::Incoming => (predecessor, edge),
            })
    }

    pub fn get(&self, label: &Label) -> Option<&[T::Statement]> {
        self.blocks.get(label).map(|block| block.as_slice())
    }

    fn get_mut(&mut self, label: &Label) -> Option<&mut Vec<T::Statement>> {
        self.blocks.get_mut(label)
    }

    fn get_terminator(&mut self, label: &Label) -> Option<Terminator> {
        self.blocks
            .get(label)
            .and_then(|block| block.last())
            .and_then(T::to_terminator)
    }

    fn get_terminator_mut(&mut self, label: &Label) -> Option<TerminatorMut> {
        self.blocks
            .get_mut(label)
            .and_then(|block| block.last_mut())
            .and_then(T::to_terminator_mut)
    }
}

impl<T: Function> Cfg<T>
where
    T::Statement: fmt::Display,
{
    fn display(&self) -> dot::Dot<T> {
        dot::Dot::new(self, |_, statements| {
            let mut string = String::new();
            for statement in statements {
                writeln!(&mut string, "{}", statement)?;
            }
            Ok(string)
        })
    }
}

impl<T: Function> fmt::Display for Cfg<T>
where
    T::Statement: fmt::Display,
{
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.display())
    }
}

impl<T: Function> fmt::Display for ir::Unit<Cfg<T>>
where
    T::Statement: fmt::Display,
{
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.map_ref(|cfg| cfg.display()))
    }
}

impl<T: Function> ops::Index<&Label> for Cfg<T> {
    type Output = [T::Statement];
    fn index(&self, index: &Label) -> &Self::Output {
        &self.blocks[index]
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Edge {
    Unconditional,
    Conditional(bool),
}

/// Represents a type that can be converted to and from a control flow graph.
pub trait Function {
    type Statement: Clone;
    type Metadata: Clone;
    type Fallthrough;

    fn new(
        name: Symbol,
        statements: Vec<Self::Statement>,
        metadata: Self::Metadata,
        enter: Label,
        exit: Label,
    ) -> Self::Fallthrough;

    fn name(&self) -> Symbol;
    fn metadata(&self) -> Self::Metadata;
    fn statements(&mut self) -> Vec<Self::Statement>;
    fn enter(&self) -> Option<&Label>;
    fn exit(&self) -> Option<&Label>;

    fn jump(label: Label) -> Self::Statement;
    fn label(label: Label) -> Self::Statement;
    fn to_terminator(statement: &Self::Statement) -> Option<Terminator>;
    fn to_terminator_mut(statement: &mut Self::Statement) -> Option<TerminatorMut>;
}

pub enum Terminator {
    Label(Label),
    Jump(Label),
    CJump {
        r#true: Label,
        r#false: Option<Label>,
    },
    Return,
}

pub enum TerminatorMut<'a> {
    Jump(&'a mut Label),
    CJump {
        r#true: &'a mut Label,
        r#false: Option<&'a mut Label>,
    },
}

impl<T: lir::Target> Function for lir::Function<T> {
    type Statement = lir::Statement<T>;
    type Metadata = (usize, usize, ir::Linkage);
    type Fallthrough = lir::Function<lir::Fallthrough>;

    fn new(
        name: Symbol,
        statements: Vec<Self::Statement>,
        (arguments, returns, linkage): Self::Metadata,
        enter: Label,
        exit: Label,
    ) -> Self::Fallthrough {
        lir::Function {
            name,
            statements: statements
                .into_iter()
                .map(|statement| match statement {
                    lir::Statement::Jump(label) => lir::Statement::Jump(label),
                    lir::Statement::Return(returns) => lir::Statement::Return(returns),
                    lir::Statement::Label(label) => lir::Statement::Label(label),
                    lir::Statement::Call(function, arguments, returns) => {
                        lir::Statement::Call(function, arguments, returns)
                    }
                    lir::Statement::Move {
                        destination,
                        source,
                    } => lir::Statement::Move {
                        destination,
                        source,
                    },
                    lir::Statement::CJump {
                        condition,
                        left,
                        right,
                        r#true,
                        r#false: _,
                    } => lir::Statement::CJump {
                        condition,
                        left,
                        right,
                        r#true,
                        r#false: lir::Fallthrough,
                    },
                })
                .collect(),
            arguments,
            returns,
            linkage,
            enter,
            exit,
        }
    }

    fn name(&self) -> Symbol {
        self.name
    }

    fn metadata(&self) -> Self::Metadata {
        (self.arguments, self.returns, self.linkage)
    }

    fn statements(&mut self) -> Vec<Self::Statement> {
        mem::take(&mut self.statements)
    }

    fn enter(&self) -> Option<&Label> {
        T::access(&self.enter)
    }

    fn exit(&self) -> Option<&Label> {
        T::access(&self.exit)
    }

    fn jump(label: Label) -> Self::Statement {
        lir::Statement::Jump(label)
    }

    fn label(label: Label) -> Self::Statement {
        lir::Statement::Label(label)
    }

    fn to_terminator(statement: &Self::Statement) -> Option<Terminator> {
        match statement {
            lir::Statement::Jump(label) => Some(Terminator::Jump(*label)),
            lir::Statement::CJump {
                condition: _,
                left: _,
                right: _,
                r#true,
                r#false,
            } => Some(Terminator::CJump {
                r#true: *r#true,
                r#false: r#false.target().copied(),
            }),
            lir::Statement::Call(_, _, _) => None,
            lir::Statement::Label(label) => Some(Terminator::Label(*label)),
            lir::Statement::Move {
                destination: _,
                source: _,
            } => None,
            lir::Statement::Return(_) => Some(Terminator::Return),
        }
    }

    fn to_terminator_mut(statement: &mut Self::Statement) -> Option<TerminatorMut> {
        match statement {
            lir::Statement::Jump(label) => Some(TerminatorMut::Jump(label)),
            lir::Statement::CJump {
                condition: _,
                left: _,
                right: _,
                r#true,
                r#false,
            } => Some(TerminatorMut::CJump {
                r#true,
                r#false: r#false.target_mut(),
            }),
            _ => None,
        }
    }
}

impl Function for asm::Function<Temporary> {
    type Statement = asm::Statement<Temporary>;
    type Metadata = (usize, usize, ir::Linkage);
    type Fallthrough = asm::Function<Temporary>;

    fn new(
        name: Symbol,
        statements: Vec<Self::Statement>,
        (arguments, returns, linkage): Self::Metadata,
        enter: Label,
        exit: Label,
    ) -> Self {
        asm::Function {
            name,
            statements,
            arguments,
            returns,
            linkage,
            enter,
            exit,
        }
    }

    fn name(&self) -> Symbol {
        self.name
    }

    fn metadata(&self) -> Self::Metadata {
        (self.arguments, self.returns, self.linkage)
    }

    fn statements(&mut self) -> Vec<Self::Statement> {
        mem::take(&mut self.statements)
    }

    fn enter(&self) -> Option<&Label> {
        Some(&self.enter)
    }

    fn exit(&self) -> Option<&Label> {
        Some(&self.exit)
    }

    fn jump(label: Label) -> Self::Statement {
        asm::Statement::Jmp(label)
    }

    fn label(label: Label) -> Self::Statement {
        asm::Statement::Label(label)
    }

    fn to_terminator(statement: &Self::Statement) -> Option<Terminator> {
        match statement {
            asm::Statement::Nullary(asm::Nullary::Nop)
            | asm::Statement::Nullary(asm::Nullary::Cqo)
            // Note: `ret` is ignored here at the abstract assembly level.
            //
            // There is guaranteed to be exactly one `ret` statement at
            // the very end, so it doesn't need any jumps or edges in the CFG.
            | asm::Statement::Nullary(asm::Nullary::Ret(_)) => None,
            asm::Statement::Binary(_, _) => None,
            asm::Statement::Unary(_, _) => None,
            asm::Statement::Label(label) => Some(Terminator::Label(*label)),
            asm::Statement::Jmp(label) => Some(Terminator::Jump(*label)),
            asm::Statement::Jcc(_, label) => Some(Terminator::CJump {
                r#true: *label,
                r#false: None,
            }),
        }
    }

    fn to_terminator_mut(statement: &mut Self::Statement) -> Option<TerminatorMut> {
        match statement {
            asm::Statement::Jmp(label) => Some(TerminatorMut::Jump(label)),
            asm::Statement::Jcc(_, label) => Some(TerminatorMut::CJump {
                r#true: label,
                r#false: None,
            }),
            _ => None,
        }
    }
}
