mod construct;
mod destruct;
mod dot;

pub use construct::construct_cfg;
pub use destruct::destruct_cfg;
pub(crate) use dot::Dot;

use std::collections::BTreeMap;
use std::fmt;
use std::fmt::Write as _;
use std::ops;

use petgraph::algo;
use petgraph::graphmap::DiGraphMap;
use petgraph::graphmap::NeighborsDirected;
use petgraph::visit;

use crate::data::asm;
use crate::data::ir;
use crate::data::lir;
use crate::data::operand::Label;
use crate::data::operand::Temporary;
use crate::data::symbol::Symbol;

pub struct Cfg<T: Function> {
    name: Symbol,
    metadata: T::Metadata,
    enter: Label,
    exit: Label,
    graph: DiGraphMap<Label, Edge>,
    blocks: BTreeMap<Label, Vec<T::Statement>>,
}

impl<T: Function> Cfg<T> {
    pub fn name(&self) -> &Symbol {
        &self.name
    }

    pub fn enter(&self) -> &Label {
        &self.enter
    }

    pub fn exit(&self) -> &Label {
        &self.exit
    }

    /// Computes the strongly connected components (SCCs) of this (`reverse`d) control flow graph.
    ///
    /// The list of SCCs is in reverse topological order. Moreover, the list of labels in each
    /// SCC is in postorder, with the component root last.
    pub fn strongly_connected_components(&self, reverse: bool) -> Vec<Vec<Label>> {
        // Wikipedia says:
        //
        // > ... there is nothing special about the order of the nodes within
        // > each strongly connected component...
        //
        // and the `petgraph::algo::tarjan_scc` documentation says:
        //
        // > The order of node ids within each scc is arbitrary...
        //
        // But as far as I can tell from reading the algorithm and source code,
        // the SCCs are generated by postorder traversal?
        if reverse {
            algo::tarjan_scc(visit::Reversed(&self.graph))
        } else {
            algo::tarjan_scc(&self.graph)
        }
    }

    pub fn blocks(&self) -> impl Iterator<Item = (&Label, &[T::Statement])> {
        self.blocks
            .iter()
            .map(|(label, statement)| (label, statement.as_slice()))
    }

    pub fn edges(&self) -> impl Iterator<Item = (Label, Label, &Edge)> {
        self.graph.all_edges()
    }

    pub fn incoming(&self, label: &Label) -> NeighborsDirected<Label, petgraph::Directed> {
        self.graph
            .neighbors_directed(*label, petgraph::Direction::Incoming)
    }

    pub fn outgoing(&self, label: &Label) -> NeighborsDirected<Label, petgraph::Directed> {
        self.graph
            .neighbors_directed(*label, petgraph::Direction::Outgoing)
    }

    pub fn get(&self, label: &Label) -> Option<&[T::Statement]> {
        self.blocks.get(label).map(|block| block.as_slice())
    }
}

impl<T: Function> Cfg<T>
where
    T::Statement: fmt::Display,
{
    fn display(&self) -> dot::Dot<T> {
        dot::Dot::new(self, |_, statements| {
            let mut string = String::new();
            for statement in statements {
                writeln!(&mut string, "{}", statement)?;
            }
            Ok(string)
        })
    }
}

impl<T: Function> fmt::Display for Cfg<T>
where
    T::Statement: fmt::Display,
{
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.display())
    }
}

impl<T: Function> fmt::Display for ir::Unit<Cfg<T>>
where
    T::Statement: fmt::Display,
{
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{}", self.map(|cfg| cfg.display()))
    }
}

impl<T: Function> ops::Index<&Label> for Cfg<T> {
    type Output = [T::Statement];
    fn index(&self, index: &Label) -> &Self::Output {
        &self.blocks[index]
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Edge {
    Unconditional,
    Conditional(bool),
}

/// Represents a type that can be converted to and from a control flow graph.
pub trait Function {
    type Statement: Clone;
    type Metadata: Clone;
    type Fallthrough;

    fn new(
        name: Symbol,
        statements: Vec<Self::Statement>,
        metadata: Self::Metadata,
        enter: Label,
        exit: Label,
    ) -> Self::Fallthrough;

    fn name(&self) -> Symbol;
    fn metadata(&self) -> Self::Metadata;
    fn statements(&self) -> &[Self::Statement];
    fn enter(&self) -> Option<&Label>;
    fn exit(&self) -> Option<&Label>;

    fn jump(label: Label) -> Self::Statement;
    fn label(label: Label) -> Self::Statement;
    fn to_terminator(statement: &Self::Statement) -> Option<Terminator>;
}

pub enum Terminator {
    Label(Label),
    Jump(Label),
    CJump {
        r#true: Label,
        r#false: Option<Label>,
    },
    Return,
}

impl<T: lir::Target> Function for lir::Function<T> {
    type Statement = lir::Statement<T>;
    type Metadata = (usize, usize);
    type Fallthrough = lir::Function<lir::Fallthrough>;

    fn new(
        name: Symbol,
        statements: Vec<Self::Statement>,
        (arguments, returns): Self::Metadata,
        enter: Label,
        exit: Label,
    ) -> Self::Fallthrough {
        lir::Function {
            name,
            statements: statements
                .into_iter()
                .map(|statement| match statement {
                    lir::Statement::Jump(label) => lir::Statement::Jump(label),
                    lir::Statement::Return(returns) => lir::Statement::Return(returns),
                    lir::Statement::Label(label) => lir::Statement::Label(label),
                    lir::Statement::Call(function, arguments, returns) => {
                        lir::Statement::Call(function, arguments, returns)
                    }
                    lir::Statement::Move {
                        destination,
                        source,
                    } => lir::Statement::Move {
                        destination,
                        source,
                    },
                    lir::Statement::CJump {
                        condition,
                        left,
                        right,
                        r#true,
                        r#false: _,
                    } => lir::Statement::CJump {
                        condition,
                        left,
                        right,
                        r#true,
                        r#false: lir::Fallthrough,
                    },
                })
                .collect(),
            arguments,
            returns,
            enter,
            exit,
        }
    }

    fn name(&self) -> Symbol {
        self.name
    }

    fn metadata(&self) -> Self::Metadata {
        (self.arguments, self.returns)
    }

    fn statements(&self) -> &[Self::Statement] {
        &self.statements
    }

    fn enter(&self) -> Option<&Label> {
        T::access(&self.enter)
    }

    fn exit(&self) -> Option<&Label> {
        T::access(&self.exit)
    }

    fn jump(label: Label) -> Self::Statement {
        lir::Statement::Jump(label)
    }

    fn label(label: Label) -> Self::Statement {
        lir::Statement::Label(label)
    }

    fn to_terminator(statement: &Self::Statement) -> Option<Terminator> {
        match statement {
            lir::Statement::Jump(label) => Some(Terminator::Jump(*label)),
            lir::Statement::CJump {
                condition: _,
                left: _,
                right: _,
                r#true,
                r#false,
            } => Some(Terminator::CJump {
                r#true: *r#true,
                r#false: r#false.target().copied(),
            }),
            lir::Statement::Call(_, _, _) => None,
            lir::Statement::Label(label) => Some(Terminator::Label(*label)),
            lir::Statement::Move {
                destination: _,
                source: _,
            } => None,
            lir::Statement::Return(_) => Some(Terminator::Return),
        }
    }
}

impl Function for asm::Function<Temporary> {
    type Statement = asm::Statement<Temporary>;
    type Metadata = (usize, usize, usize, usize);
    type Fallthrough = asm::Function<Temporary>;

    fn new(
        name: Symbol,
        statements: Vec<Self::Statement>,
        (arguments, returns, callee_arguments, callee_returns): Self::Metadata,
        enter: Label,
        exit: Label,
    ) -> Self {
        asm::Function {
            name,
            statements,
            arguments,
            returns,
            callee_arguments,
            callee_returns,
            enter,
            exit,
        }
    }

    fn name(&self) -> Symbol {
        self.name
    }

    fn metadata(&self) -> Self::Metadata {
        (
            self.arguments,
            self.returns,
            self.callee_arguments,
            self.callee_returns,
        )
    }

    fn statements(&self) -> &[Self::Statement] {
        &self.statements
    }

    fn enter(&self) -> Option<&Label> {
        Some(&self.enter)
    }

    fn exit(&self) -> Option<&Label> {
        Some(&self.exit)
    }

    fn jump(label: Label) -> Self::Statement {
        asm::Statement::Jmp(label)
    }

    fn label(label: Label) -> Self::Statement {
        asm::Statement::Label(label)
    }

    fn to_terminator(statement: &Self::Statement) -> Option<Terminator> {
        match statement {
            asm::Statement::Nullary(asm::Nullary::Nop)
            | asm::Statement::Nullary(asm::Nullary::Cqo)
            // Note: `ret` is ignored here at the abstract assembly level.
            //
            // There is guaranteed to be exactly one `ret` statement at
            // the very end, so it doesn't need any jumps or edges in the CFG.
            | asm::Statement::Nullary(asm::Nullary::Ret(_)) => None,
            asm::Statement::Binary(_, _) => None,
            asm::Statement::Unary(_, _) => None,
            asm::Statement::Label(label) => Some(Terminator::Label(*label)),
            asm::Statement::Jmp(label) => Some(Terminator::Jump(*label)),
            asm::Statement::Jcc(_, label) => Some(Terminator::CJump {
                r#true: *label,
                r#false: None,
            }),
        }
    }
}
