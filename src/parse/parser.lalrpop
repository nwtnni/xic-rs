use std::str::FromStr;

use crate::ast::*;
use crate::error::Error;
use crate::parse;
use crate::symbol::Symbol;
use crate::span::{Point, Span};
use crate::token::Token;
use crate::util::{Conv, Tap};

grammar;

pub Test: char = {
    <Value> => 'a',      
}

Comma<T>: Vec<T> = {
    <h: T?> <t: ("," <T>)*> => {
        match h {
        | None => t,
        | Some(e) => {
            let mut t = t;
            t.insert(0, e);
            t
        }
        }
    }
}

Value: Exp = {
    <l: @L> "true"   <r: @R> => Exp::Bool(true, Span::new(l, r)),
    <l: @L> "false"  <r: @R> => Exp::Bool(false, Span::new(l, r)),
    <l: @L> <v: ID>  <r: @R> => Exp::Var(v, Span::new(l, r)),
    <l: @L> <c: CHR> <r: @R> => Exp::Chr(c, Span::new(l, r)),
    <l: @L> <s: STR> <r: @R> => Exp::Str(s, Span::new(l, r)),
    <l: @L> "-" <i: INT> <r: @R> =>? {
        let mut i = i; i.insert(0, '-');
        let s = Span::new(l, r);
        let i = i64::from_str(&i) 
            .map_err(|_| parse::Error::Integer(s).into())
            .map_err(|error| lalrpop_util::ParseError::User { error })?;
        Ok(Exp::Int(i, s))
    },
    <l: @L> <i: INT> <r: @R> =>? {
        let s = Span::new(l, r);
        let i = i64::from_str(&i)
            .map_err(|_| parse::Error::Integer(s).into())
            .map_err(|error| lalrpop_util::ParseError::User { error })?;
        Ok(Exp::Int(i, s))
    },
}

extern {
    type Location = Point;
    type Error = Error;

    enum Token {
        ID       => Token::IDENT(<Symbol>),
        CHR      => Token::CHARACTER(<char>),
        INT      => Token::INTEGER(<String>),
        STR      => Token::STRING(<String>),
        "use"    => Token::USE,
        "if"     => Token::IF,
        "while"  => Token::WHILE,
        "else"   => Token::ELSE,
        "return" => Token::RETURN,
        "length" => Token::LENGTH,
        "int"    => Token::INT,
        "bool"   => Token::BOOL,
        "true"   => Token::TRUE,
        "false"  => Token::FALSE,
        "="      => Token::ASSIGN,
        "!"      => Token::NOT,
        "*"      => Token::MUL,
        "*>>"    => Token::HUL,
        "/"      => Token::DIV,
        "%"      => Token::MOD,
        "+"      => Token::ADD,
        "-"      => Token::SUB,
        "<"      => Token::LT,
        "<="     => Token::LE,
        ">="     => Token::GE,
        ">"      => Token::GT,
        "=="     => Token::EQ,
        "!="     => Token::NE,
        "&"      => Token::AND,
        "|"      => Token::OR,
        "("      => Token::LPAREN,
        ")"      => Token::RPAREN,
        "["      => Token::LBRACK,
        "]"      => Token::RBRACK,
        "{"      => Token::LBRACE,
        "}"      => Token::RBRACE,
        ":"      => Token::COLON,
        ";"      => Token::SEMICOLON,
        ","      => Token::COMMA,
        "_"      => Token::UNDERSCORE,
    }
}
