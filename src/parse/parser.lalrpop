use crate::data::ast::*;
use crate::error::Error;
use crate::parse;
use crate::parse::PreExp;
use crate::util::symbol::{Symbol, intern};
use crate::util::span::{Point, Span};
use crate::data::token::Token;

grammar;

pub Program: Program = {
    <uses: Use*> <funs: Fun+> => Program { uses, funs },
}

pub Interface: Interface = {
    <sigs: Sig+> => Interface { sigs },
}

Use: Use = {
    <l: @L> "use" <name: ID> ";"? <r: @R> => Use { name, span: Span::new(l, r) },
}

Sig: Sig = {
    <l: @L> <name: ID> "(" <args: Comma<ArgDec>> ")" <rets: (":" <CommaPlus<ArgTyp>>)?> <r: @R> => {
        let rets = if let Some(rets) = rets { rets } else { Vec::new() };
        Sig { name, args, rets, span: Span::new(l, r) }
    }
}

Fun: Fun = {
    <l: @L> <name: ID> "(" <args: Comma<ArgDec>> ")" <rets: (":" <CommaPlus<ArgTyp>>)?> <body: Block> <r: @R> => {
        let rets = if let Some(rets) = rets { rets } else { Vec::new() };
        Fun { name, args, rets, body, span: Span::new(l, r) }
    }
}

RetStm: Stm = {
    <l: @L> "return" <rets: Comma<Exp>> ";"? <r: @R> => {
        Stm::Ret(rets, Span::new(l, r))
    }
}

// Refer to http://www.parsifalsoft.com/ifelse.html
NoRetStm: Stm = {
    <OpenStm>,
    <ClosedStm>,
}

OpenStm: Stm = {
    // If statement
    <l: @L> "if" <cond: Exp> <pass: NoRetStm> <r: @R> => {
        Stm::If(cond, Box::new(pass), None, Span::new(l, r))
    },

    // If-else statement
    <l: @L> "if" <cond: Exp> <pass: ClosedStm> "else" <fail: OpenStm> <r: @R> => {
        Stm::If(cond, Box::new(pass), Some(Box::new(fail)), Span::new(l, r))
    },
}

ClosedStm: Stm = {
    // If-else statement
    <l: @L> "if" <cond: Exp> <pass: ClosedStm> "else" <fail: ClosedStm> <r: @R> => {
        Stm::If(cond, Box::new(pass), Some(Box::new(fail)), Span::new(l, r))
    },

    // Procedure call
    <call: Call> ";"? => Stm::Call(call),

    // Single declaration
    <l: @L> <dec: StmDec> ";"? <r: @R> => Stm::Dec(dec, Span::new(l, r)),

    // Single initialization
    <l: @L> <dec: StmDec> <la: @L> "=" <lr: @R> <exp: Exp> ";"? <r: @R> =>? {
        if dec.typ.has_len() { Err(parse::Error::Array(Span::new(la, lr)))? }
        Ok(Stm::Init(vec![Some(dec)], exp, Span::new(l, r)))
    },

    // Single assignment
    <l: @L> <lhs: Loc> "=" <exp: Exp> ";"? <r: @R> => {
        Stm::Ass(lhs, exp, Span::new(l, r))
    },

    // Multiple initialization
    <l: @L> <decs: Init> "=" <call: Call> ";"? <r: @R> => {
        Stm::Init(decs, Exp::Call(call), Span::new(l, r))
    },

    // While statement
    <l: @L> "while" <cond: Exp> <body: ClosedStm> <r: @R> => {
        Stm::While(cond, Box::new(body), Span::new(l, r))
    },

    <Block> ";"?,
}

// Either single wildcard or multiple declarations
Init: Vec<Option<Dec>> = {
    "_" => vec![None],
    <h: OptDec> <t: ("," <OptDec>)+> => {
        let mut t = t;
        t.insert(0, h);
        t
    }
}

Block: Stm = {
    <l: @L> "{" <stms: NoRetStm*> <ret: RetStm?> "}" <r: @R> => {
        let mut stms = stms;
        if let Some(ret) = ret { stms.push(ret); }
        Stm::Seq(stms, Span::new(l, r))
    },
}

Call: Call = {
    <l: @L> <name: ID> "(" <args: Comma<Exp>> ")" <r: @R> => {
        Call { name, args, span: Span::new(l, r) }
    },
}

Loc: Exp = {
    <l: @L> <name: ID> <r: @R> => Exp::Var(name, Span::new(l, r)),
    <l: @L> <call: Call> "[" <idx: Exp> "]" <r: @R> => {
        let call = Exp::Call(call);
        Exp::Idx(Box::new(call), Box::new(idx), Span::new(l, r))
    },
    <l: @L> <arr: Loc> "[" <idx: Exp> "]" <r: @R> => {
        Exp::Idx(Box::new(arr), Box::new(idx), Span::new(l, r))
    },
}

OptDec: Option<Dec> = {
    "_"           => None,
    <dec: StmDec> => Some(dec),
}

ArgDec: Dec = {
    <l: @L> <name: ID> ":" <typ: ArgTyp> <r: @R> => {
        Dec { name, typ, span: Span::new(l, r) }
    }
}

StmDec: Dec = {
    <l: @L> <name: ID> ":" <typ: DecTyp> <r: @R> => {
        Dec { name, typ, span: Span::new(l, r) }
    }
}

PrimTyp: Typ = {
    <l: @L> "bool" <r: @R> => Typ::Bool(Span::new(l, r)),
    <l: @L> "int"  <r: @R> => Typ::Int(Span::new(l, r)),
}

ArgTyp: Typ = {
    <PrimTyp>,
    <l: @L> <typ: ArgTyp> "[" "]" <r: @R> => {
        Typ::Arr(Box::new(typ), None, Span::new(l, r))
    },
}

DecTyp: Typ = {
    <PrimTyp>,
    <l: @L> <typ: PrimTyp> <arrs: ArrTyp+> =>? {
        let mut typ = typ;
        let mut seen = None;
        for (len, r) in arrs.into_iter().rev() {
            match (&len, &mut seen) {
            | (None, Some(span)) => return Err(parse::Error::Length(*span).into()),
            | (Some(len), ref mut seen) => **seen = Some(len.span()),
            | _ => (),
            }
            typ = Typ::Arr(Box::new(typ), len, Span::new(l, r));
        }
        Ok(typ)
    },
}

ArrTyp: (Option<Exp>, Point) = {
    "[" <len: Exp?> "]" <r: @R> => (len, r),
}

Exp: Exp = {
    <pre: PreExp> =>? pre.into_exp().map_err(|error| lalrpop_util::ParseError::User { error }),
}

Binary<Op, Next>: PreExp = {
    <l: @L> <lhs: Binary<Op, Next>> <bin: Op> <rhs: Next> <r: @R> => {
        PreExp::Bin(bin, Box::new(lhs), Box::new(rhs), Span::new(l, r))
    },
    <Next>
}

PreExp: PreExp = Or;

OrOp: Bin = {
    "|" => Bin::Or,
}

Or: PreExp = Binary<OrOp, And>;

AndOp: Bin = {
    "&" => Bin::And,
}

And: PreExp = Binary<AndOp, Equal>;

EqualOp: Bin = {
    "==" => Bin::Eq,
    "!=" => Bin::Ne,
}

Equal: PreExp = Binary<EqualOp, Compare>;

CompareOp: Bin = {
    "<"  => Bin::Lt,
    "<=" => Bin::Le,
    ">=" => Bin::Ge,
    ">"  => Bin::Gt,
}

Compare: PreExp = Binary<CompareOp, Add>;

AddOp: Bin = {
    "+" => Bin::Add,
    "-" => Bin::Sub,
}

Add: PreExp = Binary<AddOp, Mul>;

MulOp: Bin = {
    "*"   => Bin::Mul,
    "*>>" => Bin::Hul,
    "/"   => Bin::Div,
    "%"   => Bin::Mod,
}

Mul: PreExp = Binary<MulOp, Prefix>;

PrefixOp: Uno = {
    "-" => Uno::Neg,
    "!" => Uno::Not,
}

Prefix: PreExp = {
    <l: @L> <uno: PrefixOp> <exp: Prefix> <r: @R> => {
        PreExp::Uno(uno, Box::new(exp), Span::new(l, r))
    },
    <Postfix>
}

Postfix: PreExp = {
    <l: @L> <arr: Postfix> "[" <idx: PreExp> "]" <r: @R> => {
        PreExp::Idx(Box::new(arr), Box::new(idx), Span::new(l, r))
    },
    <Value>
}

Value: PreExp = {
    <call: Call>             => PreExp::Call(call),
    <l: @L> "true"   <r: @R> => PreExp::Bool(true, Span::new(l, r)),
    <l: @L> "false"  <r: @R> => PreExp::Bool(false, Span::new(l, r)),
    <l: @L> <c: CHR> <r: @R> => PreExp::Chr(c, Span::new(l, r)),
    <l: @L> <s: STR> <r: @R> => PreExp::Str(s, Span::new(l, r)),
    <l: @L> <i: INT> <r: @R> => PreExp::Int(i, Span::new(l, r)),
    <l: @L> <v: ID>  <r: @R> => PreExp::Var(v, Span::new(l, r)),
    <l: @L> "{" <exps: Comma<PreExp>> ","? "}" <r: @R> => {
        PreExp::Arr(exps, Span::new(l, r))
    },
    <l: @L> "(" <exp: PreExp> ")" <r: @R> => {
        let mut exp = exp;
        *exp.span_mut() = Span::new(l, r);
        exp
    },
    <l: @L> "length" "(" <arg: Exp> ")" <r: @R> => {
        PreExp::Call(Call {
            name: intern("length"),
            args: vec![arg],
            span: Span::new(l, r)
        })
    },
}

#[inline]
Comma<T>: Vec<T> = {
    <h: T?> <t: ("," <T>)*> => {
        match h {
        | None => t,
        | Some(e) => {
            let mut t = t;
            t.insert(0, e);
            t
        }
        }
    }
}

CommaPlus<T>: Vec<T> = {
    <h: T> <t: ("," <T>)*> => {
        let mut t = t;
        t.insert(0, h);
        t
    }
}

extern {
    type Location = Point;
    type Error = Error;

    enum Token {
        ID       => Token::IDENT(<Symbol>),
        CHR      => Token::CHARACTER(<char>),
        INT      => Token::INTEGER(<String>),
        STR      => Token::STRING(<String>),
        "use"    => Token::USE,
        "if"     => Token::IF,
        "while"  => Token::WHILE,
        "else"   => Token::ELSE,
        "length" => Token::LENGTH,
        "return" => Token::RETURN,
        "int"    => Token::INT,
        "bool"   => Token::BOOL,
        "true"   => Token::TRUE,
        "false"  => Token::FALSE,
        "="      => Token::ASSIGN,
        "!"      => Token::NOT,
        "*"      => Token::MUL,
        "*>>"    => Token::HUL,
        "/"      => Token::DIV,
        "%"      => Token::MOD,
        "+"      => Token::ADD,
        "-"      => Token::SUB,
        "<"      => Token::LT,
        "<="     => Token::LE,
        ">="     => Token::GE,
        ">"      => Token::GT,
        "=="     => Token::EQ,
        "!="     => Token::NE,
        "&"      => Token::AND,
        "|"      => Token::OR,
        "("      => Token::LPAREN,
        ")"      => Token::RPAREN,
        "["      => Token::LBRACK,
        "]"      => Token::RBRACK,
        "{"      => Token::LBRACE,
        "}"      => Token::RBRACE,
        ":"      => Token::COLON,
        ";"      => Token::SEMICOLON,
        ","      => Token::COMMA,
        "_"      => Token::UNDERSCORE,
    }
}
