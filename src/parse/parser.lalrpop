use std::str::FromStr;

use crate::ast::*;
use crate::error::Error;
use crate::parse;
use crate::parse::PreExp;
use crate::symbol::Symbol;
use crate::span::{Point, Span};
use crate::token::Token;
use crate::util::{Conv, Tap};

grammar;

pub Test: char = {
    <Value> => 'a',
}

Comma<T>: Vec<T> = {
    <h: T?> <t: ("," <T>)*> => {
        match h {
        | None => t,
        | Some(e) => {
            let mut t = t;
            t.insert(0, e);
            t
        }
        }
    }
}

RetStm: Stm = {
    <l: @L> "return" <rets: Comma<Exp>> ";"? <r: @R> => {
        Stm::Ret(rets, Span::new(l, r))
    }
}

NoRetStm: Stm = {
    // Procedure call
    <call: Call> ";"? => Stm::Call(call),

    // Single declaration
    <l: @L> <dec: StmDec> ";"? <r: @R> => Stm::Dec(dec, Span::new(l, r)),

    // Single initialization
    <l: @L> <dec: StmDec> "=" <exp: Exp> ";"? <r: @R> => {
        Stm::Init(dec, exp, Span::new(l, r))
    },

    // Single assignment
    <l: @L> <lhs: Loc> "=" <exp: Exp> ";"? <r: @R> => {
        Stm::Ass(lhs, exp, Span::new(l, r))
    },

    // Multiple initialization
    <l: @L> <decs: OptDec+> "=" <call: Call> ";"? <r: @R> => {
        Stm::Mint(decs, call, Span::new(l, r))
    },

    // If statement
    <l: @L> "if" <cond: Exp> <pass: Block> <fail: Else?> <r: @R> => {
        Stm::If(cond, Box::new(pass), fail.map(Box::new), Span::new(l, r))
    },

    // While statement
    <l: @L> "while" <cond: Exp> <body: Block> <r: @R> => {
        Stm::While(cond, Box::new(body), Span::new(l, r))
    },

    <Block>,
}

Else: Stm = { "else" <Block> }

Block: Stm = {
    <l: @L> "{" <stms: NoRetStm*> <ret: RetStm?> "}" ";"? <r: @R> => {
        let mut stms = stms;
        if let Some(ret) = ret { stms.push(ret); }
        Stm::Seq(stms, Span::new(l, r))
    },
}

Call: Call = {
    <l: @L> <name: ID> "(" <args: Comma<Exp>> ")" <r: @R> => {
        Call { name, args, span: Span::new(l, r) }
    },
}

Loc: Exp = {
    <l: @L> <name: ID> <r: @R> => Exp::Var(name, Span::new(l, r)),
    <l: @L> <arr: Loc> "[" <idx: Exp> "]" <r: @R> => {
        Exp::Idx(Box::new(arr), Box::new(idx), Span::new(l, r))
    },
}

OptDec: Option<Dec> = {
    "_"           => None,
    <dec: StmDec> => Some(dec),
}

StmDec: Dec = {
    <l: @L> <name: ID> ":" <typ: DecTyp> <r: @R> => {
        Dec { name, typ, span: Span::new(l, r) }
    }
}

PrimTyp: Typ = {
    <l: @L> "bool" <r: @R> => Typ::Bool(Span::new(l, r)),
    <l: @L> "int"  <r: @R> => Typ::Int(Span::new(l, r)),
}

ArgTyp: Typ = {
    <PrimTyp>,
    <l: @L> <typ: ArgTyp> "[" "]" <r: @R> => {
        Typ::Arr(Box::new(typ), None, Span::new(l, r))
    },
}

DecTyp: Typ = {
    <PrimTyp>,
    <l: @L> <typ: PrimTyp> <arrs: ArrTyp+> <r: @R> => {
        let mut arrs = arrs;
        let mut typ = typ;
        let (len, r) = arrs.remove(0);
        for (len, r) in arrs.into_iter().rev() {
            typ = Typ::Arr(Box::new(typ), len, Span::new(l, r));
        }
        Typ::Arr(Box::new(typ), len, Span::new(l, r))
    },
}

ArrTyp: (Option<Exp>, Point) = {
    "[" <len: Exp?> "]" <r: @R> => (len, r),
}

Exp: Exp = {
    <pre: PreExp> =>? pre.into_exp().map_err(|error| lalrpop_util::ParseError::User { error }),
}

Binary<Op, Next>: PreExp = {
    <l: @L> <lhs: Binary<Op, Next>> <bin: Op> <rhs: Next> <r: @R> => {
        PreExp::Bin(bin, Box::new(lhs), Box::new(rhs), Span::new(l, r))
    },
    <Next>
}

PreExp: PreExp = Or;

OrOp: Bin = {
    "|" => Bin::Or,
}

Or: PreExp = Binary<OrOp, And>;

AndOp: Bin = {
    "&" => Bin::And,
}

And: PreExp = Binary<AndOp, Equal>;

EqualOp: Bin = {
    "==" => Bin::Eq,
    "!=" => Bin::Ne,
}

Equal: PreExp = Binary<EqualOp, Compare>;

CompareOp: Bin = {
    "<"  => Bin::Lt,
    "<=" => Bin::Le,
    ">=" => Bin::Ge,
    ">"  => Bin::Gt,
}

Compare: PreExp = Binary<CompareOp, Add>;

AddOp: Bin = {
    "+" => Bin::Add,
    "-" => Bin::Sub,
}

Add: PreExp = Binary<AddOp, Mul>;

MulOp: Bin = {
    "*"   => Bin::Mul,
    "*>>" => Bin::Hul,
    "/"   => Bin::Div,
    "%"   => Bin::Mod,
}

Mul: PreExp = Binary<MulOp, Prefix>;

PrefixOp: Uno = {
    "-" => Uno::Neg,
    "!" => Uno::Not,
}

Prefix: PreExp = {
    <l: @L> <uno: PrefixOp> <exp: Prefix> <r: @R> => {
        PreExp::Uno(uno, Box::new(exp), Span::new(l, r))
    },
    <Postfix>
}

Postfix: PreExp = {
    <l: @L> <arr: Postfix> "[" <idx: PreExp> "]" <r: @R> => {
        PreExp::Idx(Box::new(arr), Box::new(idx), Span::new(l, r))
    },
    <Value>
}

Value: PreExp = {
    <call: Call>             => PreExp::Call(call),
    <l: @L> "true"   <r: @R> => PreExp::Bool(true, Span::new(l, r)),
    <l: @L> "false"  <r: @R> => PreExp::Bool(false, Span::new(l, r)),
    <l: @L> <c: CHR> <r: @R> => PreExp::Chr(c, Span::new(l, r)),
    <l: @L> <s: STR> <r: @R> => PreExp::Str(s, Span::new(l, r)),
    <l: @L> <i: INT> <r: @R> => PreExp::Int(i, Span::new(l, r)),
    <l: @L> <v: ID>  <r: @R> => PreExp::Var(v, Span::new(l, r)),
    <l: @L> "{" <exps: Comma<PreExp>> "}" <r: @R> => {
        PreExp::Arr(exps, Span::new(l, r))
    },
    <l: @L> "(" <exp: PreExp> ")" <r: @R> => {
        let mut exp = exp;
        *exp.span_mut() = Span::new(l, r);
        exp
    },
}

extern {
    type Location = Point;
    type Error = Error;

    enum Token {
        ID       => Token::IDENT(<Symbol>),
        CHR      => Token::CHARACTER(<char>),
        INT      => Token::INTEGER(<String>),
        STR      => Token::STRING(<String>),
        "use"    => Token::USE,
        "if"     => Token::IF,
        "while"  => Token::WHILE,
        "else"   => Token::ELSE,
        "return" => Token::RETURN,
        "length" => Token::LENGTH,
        "int"    => Token::INT,
        "bool"   => Token::BOOL,
        "true"   => Token::TRUE,
        "false"  => Token::FALSE,
        "="      => Token::ASSIGN,
        "!"      => Token::NOT,
        "*"      => Token::MUL,
        "*>>"    => Token::HUL,
        "/"      => Token::DIV,
        "%"      => Token::MOD,
        "+"      => Token::ADD,
        "-"      => Token::SUB,
        "<"      => Token::LT,
        "<="     => Token::LE,
        ">="     => Token::GE,
        ">"      => Token::GT,
        "=="     => Token::EQ,
        "!="     => Token::NE,
        "&"      => Token::AND,
        "|"      => Token::OR,
        "("      => Token::LPAREN,
        ")"      => Token::RPAREN,
        "["      => Token::LBRACK,
        "]"      => Token::RBRACK,
        "{"      => Token::LBRACE,
        "}"      => Token::RBRACE,
        ":"      => Token::COLON,
        ";"      => Token::SEMICOLON,
        ","      => Token::COMMA,
        "_"      => Token::UNDERSCORE,
    }
}
