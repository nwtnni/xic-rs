use std::str::FromStr;

use crate::ast::*;
use crate::error::Error;
use crate::parse;
use crate::parse::Prexp;
use crate::symbol::Symbol;
use crate::span::{Point, Span};
use crate::token::Token;
use crate::util::{Conv, Tap};

grammar;

pub Test: char = {
    <Value> => 'a',      
}

Comma<T>: Vec<T> = {
    <h: T?> <t: ("," <T>)*> => {
        match h {
        | None => t,
        | Some(e) => {
            let mut t = t;
            t.insert(0, e);
            t
        }
        }
    }
}

Stm: Stm = {
    <RetStm>,
    <NoRetStm>,
}

RetStm: Stm = {
    <l: @L> "return" <rets: Comma<Exp>> ";"? <r: @R> => {
        Stm::Ret(rets, Span::new(l, r))
    }
}

NoRetStm: Stm = {
    <l: @L> <name: ID> "(" <args: Comma<Exp>> ")" ";"? <r: @R> => {
        Stm::Call(name, args, Span::new(l, r))
    },
    <Block>,
}

Block: Stm = {
    <l: @L> "{" <stms: NoRetStm*> <ret: RetStm?> "}" ";"? <r: @R> => {
        let mut stms = stms;
        if let Some(ret) = ret { stms.push(ret); }
        Stm::Seq(stms, Span::new(l, r))
    },
}

StmDec: Dec = {
    <l: @L> <name: ID> ":" <typ: DecTyp> <r: @R> => {
        Dec { name, typ, span: Span::new(l, r) }
    }
}

PrimTyp: Typ = {
    <l: @L> "bool" <r: @R> => Typ::Bool(Span::new(l, r)),
    <l: @L> "int"  <r: @R> => Typ::Int(Span::new(l, r)),
}

ArgTyp: Typ = {
    <PrimTyp>,
    <l: @L> <typ: ArgTyp> "[" "]" <r: @R> => {
        Typ::Arr(Box::new(typ), None, Span::new(l, r))
    },
}

DecTyp: Typ = {
    <PrimTyp>,
    <l: @L> <typ: PrimTyp> <arrs: ArrTyp+> <r: @R> => {
        let mut arrs = arrs;
        let mut typ = typ;
        let (len, r) = arrs.remove(0);
        for (len, r) in arrs.into_iter().rev() {
            typ = Typ::Arr(Box::new(typ), len, Span::new(l, r));
        }
        Typ::Arr(Box::new(typ), len, Span::new(l, r))
    },
}

ArrTyp: (Option<Exp>, Point) = {
    "[" <len: Exp?> "]" <r: @R> => (len, r),
}

Exp: Exp = {
    <pre: Prexp> =>? pre.into_exp().map_err(|error| lalrpop_util::ParseError::User { error }),
}

Binary<Op, Next>: Prexp = {
    <l: @L> <lhs: Binary<Op, Next>> <bin: Op> <rhs: Next> <r: @R> => {
        Prexp::Bin(bin, Box::new(lhs), Box::new(rhs), Span::new(l, r))
    },
    <Next>
}

Prexp: Prexp = Or;

OrOp: Bin = {
    "|" => Bin::Or,
}

Or: Prexp = Binary<OrOp, And>;

AndOp: Bin = {
    "&" => Bin::And,
}

And: Prexp = Binary<AndOp, Equal>;

EqualOp: Bin = {
    "==" => Bin::Eq,
    "!=" => Bin::Ne,
}

Equal: Prexp = Binary<EqualOp, Compare>;

CompareOp: Bin = {
    "<"  => Bin::Lt,
    "<=" => Bin::Le,
    ">=" => Bin::Ge,
    ">"  => Bin::Gt,
}

Compare: Prexp = Binary<CompareOp, Add>;

AddOp: Bin = {
    "+" => Bin::Add,
    "-" => Bin::Sub,
}

Add: Prexp = Binary<AddOp, Mul>;

MulOp: Bin = {
    "*"   => Bin::Mul,
    "*>>" => Bin::Hul,
    "/"   => Bin::Div,
    "%"   => Bin::Mod,
}

Mul: Prexp = Binary<MulOp, Prefix>;

PrefixOp: Uno = {
    "-" => Uno::Neg,
    "!" => Uno::Not,
}

Prefix: Prexp = {
    <l: @L> <uno: PrefixOp> <exp: Prefix> <r: @R> => {
        Prexp::Uno(uno, Box::new(exp), Span::new(l, r))
    },
    <Postfix>
}

Postfix: Prexp = {
    <l: @L> <arr: Postfix> "[" <idx: Prexp> "]" <r: @R> => {
        Prexp::Idx(Box::new(arr), Box::new(idx), Span::new(l, r))
    },
    <Value>
}

Value: Prexp = {
    <l: @L> "true"   <r: @R> => Prexp::Bool(true, Span::new(l, r)),
    <l: @L> "false"  <r: @R> => Prexp::Bool(false, Span::new(l, r)),
    <l: @L> <c: CHR> <r: @R> => Prexp::Chr(c, Span::new(l, r)),
    <l: @L> <s: STR> <r: @R> => Prexp::Str(s, Span::new(l, r)),
    <l: @L> <i: INT> <r: @R> => Prexp::Int(i, Span::new(l, r)),
    <l: @L> <v: ID>  <r: @R> => Prexp::Var(v, Span::new(l, r)),
    <l: @L> "{" <exps: Comma<Prexp>> "}" <r: @R> => {
        Prexp::Arr(exps, Span::new(l, r))   
    },
    <l: @L> <name: ID> "(" <args: Comma<Prexp>> ")" <r: @R> => {
        Prexp::Call(name, args, Span::new(l, r))
    },
    <l: @L> "(" <exp: Prexp> ")" <r: @R> => {
        let mut exp = exp;
        *exp.span_mut() = Span::new(l, r);
        exp
    },
}

extern {
    type Location = Point;
    type Error = Error;

    enum Token {
        ID       => Token::IDENT(<Symbol>),
        CHR      => Token::CHARACTER(<char>),
        INT      => Token::INTEGER(<String>),
        STR      => Token::STRING(<String>),
        "use"    => Token::USE,
        "if"     => Token::IF,
        "while"  => Token::WHILE,
        "else"   => Token::ELSE,
        "return" => Token::RETURN,
        "length" => Token::LENGTH,
        "int"    => Token::INT,
        "bool"   => Token::BOOL,
        "true"   => Token::TRUE,
        "false"  => Token::FALSE,
        "="      => Token::ASSIGN,
        "!"      => Token::NOT,
        "*"      => Token::MUL,
        "*>>"    => Token::HUL,
        "/"      => Token::DIV,
        "%"      => Token::MOD,
        "+"      => Token::ADD,
        "-"      => Token::SUB,
        "<"      => Token::LT,
        "<="     => Token::LE,
        ">="     => Token::GE,
        ">"      => Token::GT,
        "=="     => Token::EQ,
        "!="     => Token::NE,
        "&"      => Token::AND,
        "|"      => Token::OR,
        "("      => Token::LPAREN,
        ")"      => Token::RPAREN,
        "["      => Token::LBRACK,
        "]"      => Token::RBRACK,
        "{"      => Token::LBRACE,
        "}"      => Token::RBRACE,
        ":"      => Token::COLON,
        ";"      => Token::SEMICOLON,
        ","      => Token::COMMA,
        "_"      => Token::UNDERSCORE,
    }
}
