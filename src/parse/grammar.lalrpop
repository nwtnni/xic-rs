use std::cell::Cell;

use crate::data::ast::*;
use crate::data::token::Token;
use crate::error::Error;
use crate::parse;
use crate::data::symbol::Symbol;
use crate::data::symbol::intern_static;
use crate::data::span::Point;
use crate::data::span::Span;

grammar;

pub Interface: Interface = {
    <uses: Use*> <items: ItemSignature*> => Interface {
        uses,
        items,
    },
}

Use: Use = {
    <l: @L> "use" <name: ID> ";"? <r: @R> => Use { name, span: Span::new(l, r) },
}

ItemSignature: ItemSignature = {
    <class: ClassSignature> => ItemSignature::Class(class),
    <function: FunctionSignature> => ItemSignature::Function(function),
}

ClassSignature: ClassSignature = {
    <l: @L> "class" <name: ID> <extends: ("extends" <ID>)?> "{" <methods: FunctionSignature*> "}" <r: @R> => {
        ClassSignature {
            name,
            extends,
            methods,
            span: Span::new(l, r),
        }
    },
}

FunctionSignature: FunctionSignature = {
    <l: @L> <name: ID> "(" <parameters: Comma<NoLengthDeclaration>> ")" <returns: (":" <CommaPlus<NoLengthType>>)?> <r: @R> => {
        FunctionSignature {
            name,
            parameters,
            returns: returns.unwrap_or_else(Vec::new),
            span: Span::new(l, r)
        }
    }
}

pub Program: Program = {
    <uses: Use*> <items: Item*> => Program {
        uses,
        items,
    },
}

Item: Item = {
    <global: Global> => Item::Global(global),
    <class: Class> => Item::Class(class),
    <function: Function> => Item::Function(function),
}

Global: Global = {
    <l: @L> <declaration: Declaration> <value: ("=" <Expression>)?> <r: @R> => {
        Global {
            declaration,
            value,
            span: Span::new(l, r),
        }
    },
}

Class: Class = {
    <l: @L> "class" <name: ID> <extends: ("extends" <ID>)?> "{" <items: ClassItem*> "}" <r: @R> => {
        Class {
            name,
            extends,
            items,
            span: Span::new(l, r),
        }
    }
}

ClassItem: ClassItem = {
    <declaration: NoLengthDeclaration> => ClassItem::Field(declaration),
    <method: Function> => ClassItem::Method(method),
}

Function: Function = {
    <l: @L> <name: ID> "(" <parameters: Comma<NoLengthDeclaration>> ")" <returns: (":" <CommaPlus<NoLengthType>>)?> <statements: Block> <r: @R> => {
        Function {
            name,
            parameters,
            returns: returns.unwrap_or_else(Vec::new),
            statements,
            span: Span::new(l, r),
        }
    }
}

ReturnStatement: Statement = {
    <l: @L> "return" <returns: Comma<Expression>> ";"? <r: @R> => {
        Statement::Return(returns, Span::new(l, r))
    }
}

// Refer to http://www.parsifalsoft.com/ifelse.html
NoReturnStatement: Statement = {
    <OpenStatement>,
    <ClosedStatement>,
}

OpenStatement: Statement = {
    // If statement
    <l: @L> "if" <condition: Expression> <pass: NoReturnStatement> <r: @R> => {
        Statement::If(condition, Box::new(pass), None, Span::new(l, r))
    },

    // If-else statement
    <l: @L> "if" <condition: Expression> <pass: ClosedStatement> "else" <fail: OpenStatement> <r: @R> => {
        Statement::If(condition, Box::new(pass), Some(Box::new(fail)), Span::new(l, r))
    },
}

ClosedStatement: Statement = {
    // If-else statement
    <l: @L> "if" <condition: Expression> <pass: ClosedStatement> "else" <fail: ClosedStatement> <r: @R> => {
        Statement::If(condition, Box::new(pass), Some(Box::new(fail)), Span::new(l, r))
    },

    // Procedure call
    <call: Call> ";"? => Statement::Call(call),

    // Single declaration
    <l: @L> <declaration: Declaration> ";"? <r: @R> => Statement::Declaration(declaration, Span::new(l, r)),

    // Single initialization
    <l: @L> <declaration: Declaration> <la: @L> "=" <lr: @R> <expression: Expression> ";"? <r: @R> =>? {
        if declaration.has_len() { Err(parse::Error::Array(Span::new(la, lr)))? }
        Ok(Statement::Initialization(vec![Some(declaration)], expression, Span::new(l, r)))
    },

    // Single assignment
    <l: @L> <lhs: LValue> "=" <expression: Expression> ";"? <r: @R> => {
        Statement::Assignment(lhs, expression, Span::new(l, r))
    },

    // Multiple initialization
    <l: @L> <declarations: Initialization> "=" <call: Call> ";"? <r: @R> => {
        Statement::Initialization(declarations, Expression::Call(call), Span::new(l, r))
    },

    // While statement
    <l: @L> "while" <condition: Expression> <statements: ClosedStatement> <r: @R> => {
        Statement::While(Do::No, condition, Box::new(statements), Span::new(l, r))
    },

    // Do while statement
    <l: @L> "do" <statements: NoReturnStatement> "while" <condition: Expression> <r: @R> => {
        Statement::While(Do::Yes, condition, Box::new(statements), Span::new(l, r))
    },

    <Block> ";"?,
}

// Either single wildcard or multiple declarations
Initialization: Vec<Option<Declaration>> = {
    "_" => vec![None],
    <head: OptionalDeclaration> <tail: ("," <OptionalDeclaration>)+> => {
        let mut tail = tail;
        tail.insert(0, head);
        tail
    }
}

Block: Statement = {
    <l: @L> "{" <statements: NoReturnStatement*> <_return: ReturnStatement?> "}" <r: @R> => {
        let mut statements = statements;
        if let Some(_return) = _return { statements.push(_return); }
        Statement::Sequence(statements, Span::new(l, r))
    },
}

Call: Call = {
    <l: @L> <name: ID> "(" <arguments: Comma<Expression>> ")" <r: @R> => {
        Call { name, arguments, span: Span::new(l, r) }
    },
}

LValue: Expression = {
    <l: @L> <name: ID> <r: @R> => Expression::Variable(name, Span::new(l, r)),
    <l: @L> <call: Call> "[" <index: Expression> "]" <r: @R> => {
        let call = Expression::Call(call);
        Expression::Index(Box::new(call), Box::new(index), Span::new(l, r))
    },
    <l: @L> <array: LValue> "[" <index: Expression> "]" <r: @R> => {
        Expression::Index(Box::new(array), Box::new(index), Span::new(l, r))
    },
}

OptionalDeclaration: Option<Declaration> = {
    "_" => None,
    <declaration: Declaration> => Some(declaration),
}

NoLengthDeclaration: Declaration = {
    <l: @L> <name: ID> ":" <type_: NoLengthType> <r: @R> => {
        Declaration::new(name, type_, Span::new(l, r))
    }
}

Declaration: Declaration = {
    <l: @L> <name: ID> ":" <type_: DeclarationType> <r: @R> => {
        Declaration::new(name, type_, Span::new(l, r))
    }
}

NoLengthType: Type = {
    <PrimitiveType>,
    <l: @L> <type_: NoLengthType> "[" "]" <r: @R> => {
        Type::Array(Box::new(type_), None, Span::new(l, r))
    },
}

DeclarationType: Type = {
    <PrimitiveType>,
    <l: @L> <type_: PrimitiveType> <arrays: ArrayType+> =>? {
        let mut type_ = type_;
        let mut seen = None;
        for (len, r) in arrays.into_iter().rev() {
            match (&len, &mut seen) {
            | (None, Some(span)) => return Err(parse::Error::Length(*span).into()),
            | (Some(len), seen) => *seen = Some(len.span()),
            | _ => (),
            }
            type_ = Type::Array(Box::new(type_), len, Span::new(l, r));
        }
        Ok(type_)
    },
}

PrimitiveType: Type = {
    <l: @L> "bool" <r: @R> => Type::Bool(Span::new(l, r)),
    <l: @L> "int"  <r: @R> => Type::Int(Span::new(l, r)),
}

ArrayType: (Option<Expression>, Point) = {
    "[" <length: Expression?> "]" <r: @R> => (length, r),
}

Expression: Expression = Or;

Binary<Op, Next>: Expression = {
    <l: @L> <lhs: Binary<Op, Next>> <binary: Op> <rhs: Next> <r: @R> => {
        Expression::Binary(Cell::new(binary), Box::new(lhs), Box::new(rhs), Span::new(l, r))
    },
    <Next>
}

OrOp: Binary = {
    "|" => Binary::Or,
}

Or: Expression = Binary<OrOp, And>;

AndOp: Binary = {
    "&" => Binary::And,
}

And: Expression = Binary<AndOp, Equal>;

EqualOp: Binary = {
    "==" => Binary::Eq,
    "!=" => Binary::Ne,
}

Equal: Expression = Binary<EqualOp, Compare>;

CompareOp: Binary = {
    "<"  => Binary::Lt,
    "<=" => Binary::Le,
    ">=" => Binary::Ge,
    ">"  => Binary::Gt,
}

Compare: Expression = Binary<CompareOp, Add>;

AddOp: Binary = {
    "+" => Binary::Add,
    "-" => Binary::Sub,
}

Add: Expression = Binary<AddOp, Mul>;

MulOp: Binary = {
    "*"   => Binary::Mul,
    "*>>" => Binary::Hul,
    "/"   => Binary::Div,
    "%"   => Binary::Mod,
}

Mul: Expression = Binary<MulOp, Prefix>;

PrefixOp: Unary = {
    "-" => Unary::Neg,
    "!" => Unary::Not,
}

Prefix: Expression = {
    // Hack to support `i64::MIN`.
    //
    // To avoid an ambiguous parse for -INT, we diverge into non-integer
    // and integer branches here.
    <l: @L> "-" <int: INT> <r: @R> =>? {
        let span = Span::new(l, r);
        let mut int = int;
        int.insert(0, '-');
        int.parse::<i64>()
            .map_err(|_| parse::Error::Integer(span))
            .map_err(Into::into)
            .map(|int| Expression::Integer(int, span))
    },
    <l: @L> "-" <expression: NoIntPrefix> <r: @R> => {
        Expression::Unary(Unary::Neg, Box::new(expression), Span::new(l, r))
    },
    <l: @L> "!" <expression: Prefix> <r: @R> => {
        Expression::Unary(Unary::Not, Box::new(expression), Span::new(l, r))
    },
    <Postfix>
}

NoIntPrefix: Expression = {
    <l: @L> "-" <int: INT> <r: @R> =>? {
        let span = Span::new(l, r);
        let mut int = int;
        int.insert(0, '-');
        int.parse::<i64>()
            .map_err(|_| parse::Error::Integer(span))
            .map_err(Into::into)
            .map(|int| Expression::Integer(int, span))
    },
    <l: @L> "-" <expression: NoIntPrefix> <r: @R> => {
        Expression::Unary(Unary::Neg, Box::new(expression), Span::new(l, r))
    },
    <l: @L> "!" <expression: Prefix> <r: @R> => {
        Expression::Unary(Unary::Not, Box::new(expression), Span::new(l, r))
    },
    <NoIntPostfix>
}

Postfix: Expression = {
    <l: @L> <array: Postfix> "[" <index: Expression> "]" <r: @R> => {
        Expression::Index(Box::new(array), Box::new(index), Span::new(l, r))
    },
    <Value>
}

NoIntPostfix: Expression = {
    <l: @L> <array: Postfix> "[" <index: Expression> "]" <r: @R> => {
        Expression::Index(Box::new(array), Box::new(index), Span::new(l, r))
    },
    <NoIntValue>
}

Value: Expression = {
    NoIntValue,
    <l: @L> <int: INT> <r: @R> =>? {
        let span = Span::new(l, r);
        int.parse::<i64>()
            .map_err(|_| parse::Error::Integer(span))
            .map_err(Into::into)
            .map(|int| Expression::Integer(int, span))
    },
}

NoIntValue: Expression = {
    <call: Call> => Expression::Call(call),
    <l: @L> "true" <r: @R> => Expression::Boolean(true, Span::new(l, r)),
    <l: @L> "false" <r: @R> => Expression::Boolean(false, Span::new(l, r)),
    <l: @L> <char: CHR> <r: @R> => Expression::Character(char, Span::new(l, r)),
    <l: @L> <string: STR> <r: @R> => Expression::String(string, Span::new(l, r)),
    <l: @L> <var: ID>  <r: @R> => Expression::Variable(var, Span::new(l, r)),
    <l: @L> "{" <expressions: Comma<Expression>> ","? "}" <r: @R> => {
        Expression::Array(expressions, Span::new(l, r))
    },
    <l: @L> "(" <expression: Expression> ")" <r: @R> => {
        let mut expression = expression;
        *expression.span_mut() = Span::new(l, r);
        expression
    },
    <l: @L> "length" "(" <argument: Expression> ")" <r: @R> => {
        Expression::Call(Call {
            name: intern_static("length"),
            arguments: vec![argument],
            span: Span::new(l, r)
        })
    },
}

#[inline]
Comma<T>: Vec<T> = {
    <head: T?> <tail: ("," <T>)*> => {
        match head {
        | None => tail,
        | Some(head) => {
            let mut tail = tail;
            tail.insert(0, head);
            tail
        }
        }
    }
}

CommaPlus<T>: Vec<T> = {
    <head: T> <tail: ("," <T>)*> => {
        let mut tail = tail;
        tail.insert(0, head);
        tail
    }
}

extern {
    type Location = Point;
    type Error = Error;

    enum Token {
        ID => Token::Identifier(<Symbol>),
        CHR => Token::Character(<char>),
        INT => Token::Integer(<String>),
        STR => Token::String(<String>),
        "use" => Token::Use,
        "class" => Token::Class,
        "this" => Token::This,
        "new" => Token::New,
        "extends" => Token::Extends,
        "null" => Token::Null,
        "break" => Token::Break,
        "if" => Token::If,
        "do" => Token::Do,
        "while" => Token::While,
        "else" => Token::Else,
        "length" => Token::Length,
        "return" => Token::Return,
        "int" => Token::Int,
        "bool" => Token::Bool,
        "true" => Token::True,
        "false" => Token::False,
        "=" => Token::Assign,
        "!" => Token::Not,
        "*" => Token::Mul,
        "*>>" => Token::Hul,
        "/" => Token::Div,
        "%" => Token::Mod,
        "+" => Token::Add,
        "-" => Token::Sub,
        "<" => Token::Lt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        ">" => Token::Gt,
        "==" => Token::Eq,
        "!=" => Token::Ne,
        "&" => Token::And,
        "|" => Token::Or,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBrack,
        "]" => Token::RBrack,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "_" => Token::Underscore,
        "." => Token::Period,
    }
}
